# 地区管理接口文档

## 概述
本文档定义地区管理相关接口，用于提供省市区三级联动数据。

**说明**：地区数据为公共数据，管理端和用户端使用相同的接口。

**接口路径**:
- 管理端：`/api/support/regions`
- 用户端：`/api/h5/regions`

---

## 1. 地区列表

### 1.1 获取地区列表
**接口地址**: 
- 管理端：`GET /api/support/regions`
- 用户端：`GET /api/h5/regions`

**请求参数**:
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| parent_id | number | 否 | 父级地区ID，0或不传表示获取省级列表 |
| level | number | 否 | 地区层级：1=省，2=市，3=区 |

**请求示例**:
```bash
# 获取所有省份
GET /api/h5/regions?level=1

# 获取某省下的所有市（以广东省为例，ID=440000）
GET /api/h5/regions?parent_id=440000&level=2

# 获取某市下的所有区（以深圳市为例，ID=440300）
GET /api/h5/regions?parent_id=440300&level=3
```

**响应数据**:
```json
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "id": 110000,
      "name": "北京市",
      "code": "110000",
      "parent_id": 0,
      "level": 1,
      "sort_order": 1,
      "status": 1
    },
    {
      "id": 120000,
      "name": "天津市",
      "code": "120000",
      "parent_id": 0,
      "level": 1,
      "sort_order": 2,
      "status": 1
    },
    {
      "id": 440000,
      "name": "广东省",
      "code": "440000",
      "parent_id": 0,
      "level": 1,
      "sort_order": 19,
      "status": 1
    }
  ]
}
```

**说明**: 
- 不传参数时，默认返回所有省份（level=1, parent_id=0）
- `id` 直接使用国标区划代码，与 `code` 字段值相同
- `code` 为行政区划代码（省6位，市6位，区6位）
- 返回数据按 `sort_order` 排序
- `status=1` 表示启用，`status=0` 表示禁用

---

## 2. 地区详情

### 2.1 获取单个地区详情
**接口地址**: 
- 管理端：`GET /api/support/regions/:id`
- 用户端：`GET /api/h5/regions/:id`

**路径参数**:
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | number | 是 | 地区ID（国标区划代码） |

**请求示例**:
```bash
# 获取南山区详情（ID=440305）
GET /api/h5/regions/440305
```

**响应数据**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 440305,
    "name": "南山区",
    "code": "440305",
    "parent_id": 440300,
    "level": 3,
    "sort_order": 5,
    "status": 1,
    "created_at": "2024-01-01 00:00:00",
    "updated_at": "2024-01-01 00:00:00"
  }
}
```

---

## 3. 使用场景

### 3.1 三级联动选择
前端实现省市区三级联动的典型流程：

```javascript
// 1. 页面加载时，获取省份列表
GET /api/h5/regions?level=1
// 返回示例：[{ id: 110000, name: '北京市', ... }, { id: 440000, name: '广东省', ... }]

// 2. 用户选择省份后，获取该省的市列表
// 假设选择了广东省（id=440000）
GET /api/h5/regions?parent_id=440000&level=2
// 返回示例：[{ id: 440100, name: '广州市', ... }, { id: 440300, name: '深圳市', ... }]

// 3. 用户选择城市后，获取该市的区列表
// 假设选择了深圳市（id=440300）
GET /api/h5/regions?parent_id=440300&level=3
// 返回示例：[{ id: 440303, name: '罗湖区', ... }, { id: 440305, name: '南山区', ... }]

// 4. 用户最终选择了"南山区"（id=440305）
// 提交用户注册或订单时，传递地区ID
{
  "province_id": 440000,  // 广东省
  "city_id": 440300,      // 深圳市
  "district_id": 440305,  // 南山区
  "address": "科技园南区"  // 详细地址
}

// 注意：系统存储的是地区ID（国标区划代码），而非地区名称
// 前端显示时需要根据ID查询对应的地区名称
```

### 3.2 显示完整地区路径
前端显示地区信息时的处理方式：

```javascript
// 方式1：通过多次查询获取完整路径
// 假设用户表中存储了 province_id=440000, city_id=440300, district_id=440305

// 查询省份
GET /api/h5/regions/440000  // 返回：广东省

// 查询城市
GET /api/h5/regions/440300  // 返回：深圳市

// 查询区县
GET /api/h5/regions/440305  // 返回：南山区

// 最终显示：广东省 / 深圳市 / 南山区


// 方式2：前端本地缓存地区数据（推荐）
// 一次性获取所有地区数据并缓存到localStorage
// 后续根据ID直接从本地数据中查询名称
const regionCache = {
  440000: { id: 440000, name: '广东省', level: 1, parent_id: 0 },
  440300: { id: 440300, name: '深圳市', level: 2, parent_id: 440000 },
  440305: { id: 440305, name: '南山区', level: 3, parent_id: 440300 }
  // ... 其他地区
};

// 根据ID快速获取名称
const provinceName = regionCache[440000].name;  // '广东省'
const cityName = regionCache[440300].name;      // '深圳市'
const districtName = regionCache[440305].name;  // '南山区'
```

---

## 4. 数据说明

### 4.1 数据来源
- 使用国家统计局最新行政区划数据
- 参考开源项目 **modood/Administrative-divisions-of-China**
- 包含全国34个省级行政区、300+地级市、2800+区县

### 4.2 数据结构
- **ID设计**：直接使用国标区划代码作为主键（INT UNSIGNED），不使用自增ID
- **层级关系**：通过 `parent_id` 建立三级关系
  - 省级：`parent_id = 0`
  - 市级：`parent_id = 省ID`
  - 区县级：`parent_id = 市ID`

### 4.3 行政区划代码说明
- **省级**：6位，后4位为0（如：北京市 110000）
- **市级**：6位，后2位为0（如：深圳市 440300）
- **区县级**：6位（如：南山区 440305）

### 4.4 数据示例
```sql
-- 省级（level=1, parent_id=0）
INSERT INTO regions VALUES (110000, '北京市', '110000', 0, 1, 1, 1, NOW(), NOW());
INSERT INTO regions VALUES (440000, '广东省', '440000', 0, 1, 19, 1, NOW(), NOW());

-- 市级（level=2, parent_id=省id）
INSERT INTO regions VALUES (110100, '市辖区', '110100', 110000, 2, 1, 1, NOW(), NOW());
INSERT INTO regions VALUES (440300, '深圳市', '440300', 440000, 2, 3, 1, NOW(), NOW());

-- 区县级（level=3, parent_id=市id）
INSERT INTO regions VALUES (110101, '东城区', '110101', 110100, 3, 1, 1, NOW(), NOW());
INSERT INTO regions VALUES (440305, '南山区', '440305', 440300, 3, 5, 1, NOW(), NOW());
```

### 4.5 数据更新
- 数据相对稳定，通常每年更新1-2次
- 如需更新，可直接替换 regions 表数据
- 更新时保持ID（国标区划代码）一致，不影响历史数据

---

## 5. 与现有表的关系

### 5.1 用户表（users）
用户注册时需要选择省市区，存储地区ID：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| province_id | INT UNSIGNED | 省份ID（国标区划代码，如：440000） |
| city_id | INT UNSIGNED | 城市ID（国标区划代码，如：440300） |
| district_id | INT UNSIGNED | 区县ID（国标区划代码，如：440305） |
| address | VARCHAR(200) | 详细地址（街道门牌号等） |

**使用示例**：
```javascript
// 用户注册提交数据
{
  "name": "张三",
  "phone": "13800138000",
  "province_id": 440000,    // 广东省
  "city_id": 440300,        // 深圳市
  "district_id": 440305,    // 南山区
  "address": "科技园南区某某大厦",
  "organization_id": 1,
  "research_group_id": 1
}
```

### 5.2 动物订购订单表（animal_orders）
动物订单的收货地址需要省市区ID：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| province_id | INT UNSIGNED | 收货省份ID |
| city_id | INT UNSIGNED | 收货城市ID |
| district_id | INT UNSIGNED | 收货区县ID |
| address | VARCHAR(200) | 详细收货地址 |

**使用示例**：
```javascript
// 动物订购提交数据
{
  "brand_id": 1,
  "variety_id": 1,
  "specification_id": 1,
  "gender": 1,
  "supervisor_name": "李教授",
  "orderer_name": "张三",
  "contact_phone": "13800138000",
  "delivery_date": "2024-12-20",
  "province_id": 440000,    // 广东省
  "city_id": 440300,        // 深圳市
  "district_id": 440305,    // 南山区
  "address": "科技园南区某某实验室",
  "environment_id": 1,
  "requirement_id": 1,
  "remark": "请在工作日送货"
}
```

### 5.3 试剂耗材订购订单表（reagent_orders）
试剂订单的收货地址需要省市区ID：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| province_id | INT UNSIGNED | 收货省份ID |
| city_id | INT UNSIGNED | 收货城市ID |
| district_id | INT UNSIGNED | 收货区县ID |
| address | VARCHAR(200) | 详细收货地址 |

**使用示例**：
```javascript
// 试剂订购提交数据
{
  "name": "XX试剂",
  "brand_id": 1,
  "specification_id": 1,
  "quantity": 10,
  "orderer_name": "张三",
  "contact_phone": "13800138000",
  "delivery_date": "2024-12-20",
  "province_id": 440000,    // 广东省
  "city_id": 440300,        // 深圳市
  "district_id": 440305,    // 南山区
  "address": "科技园南区某某实验室",
  "remark": "请小心轻放"
}
```

### 5.4 前端显示地区信息
后端返回用户或订单数据时，建议同时返回地区名称：

**方式1：后端关联查询返回地区名称（推荐）**
```javascript
// 后端返回用户信息时，通过JOIN查询regions表获取地区名称
{
  "id": 1,
  "name": "张三",
  "phone": "13800138000",
  "province_id": 440000,
  "province_name": "广东省",    // 关联查询获取
  "city_id": 440300,
  "city_name": "深圳市",        // 关联查询获取
  "district_id": 440305,
  "district_name": "南山区",    // 关联查询获取
  "address": "科技园南区某某大厦"
}
```

**方式2：前端根据ID查询地区名称**
```javascript
// 前端收到数据后，根据province_id、city_id、district_id
// 从本地缓存或接口查询对应的地区名称
const user = {
  province_id: 440000,
  city_id: 440300,
  district_id: 440305,
  address: "科技园南区某某大厦"
};

// 查询地区名称
const provinceName = await getRegionName(user.province_id);  // '广东省'
const cityName = await getRegionName(user.city_id);          // '深圳市'
const districtName = await getRegionName(user.district_id);  // '南山区'

// 显示完整地址
const fullAddress = `${provinceName} ${cityName} ${districtName} ${user.address}`;
// 结果：广东省 深圳市 南山区 科技园南区某某大厦
```

---

## 6. 前端使用建议

### 6.1 数据缓存策略
```javascript
// 1. 初始化时加载所有地区数据并缓存
async function initRegionData() {
  // 获取所有省份
  const provinces = await fetch('/api/h5/regions?level=1').then(r => r.json());
  
  // 获取所有城市（可选：按需加载或一次性加载）
  const cities = await fetch('/api/h5/regions?level=2').then(r => r.json());
  
  // 获取所有区县（可选：按需加载或一次性加载）
  const districts = await fetch('/api/h5/regions?level=3').then(r => r.json());
  
  // 存储到localStorage（建议设置7天过期时间）
  localStorage.setItem('regionData', JSON.stringify({
    provinces,
    cities,
    districts,
    timestamp: Date.now()
  }));
}

// 2. 使用缓存数据
function getRegionFromCache(id) {
  const cache = JSON.parse(localStorage.getItem('regionData') || '{}');
  
  // 检查缓存是否过期（7天）
  if (!cache.timestamp || Date.now() - cache.timestamp > 7 * 24 * 60 * 60 * 1000) {
    initRegionData();  // 重新加载
    return null;
  }
  
  // 从缓存中查找
  return [...cache.provinces, ...cache.cities, ...cache.districts]
    .find(region => region.id === id);
}
```

### 6.3 提交表单时的数据格式
```javascript
// 用户选择完成后，提交表单
const formData = {
  // ... 其他字段
  province_id: selectedProvince.value,   // 440000（INT类型）
  city_id: selectedCity.value,           // 440300（INT类型）
  district_id: selectedDistrict.value,   // 440305（INT类型）
  address: '科技园南区某某大厦'           // 详细地址（VARCHAR类型）
};

// 发送到后端
await fetch('/api/h5/auth/register', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(formData)
});
```

---

## 7. 错误码

| 错误码 | 说明 |
|--------|------|
| 200 | 成功 |
| 400 | 参数错误（如：level不在1-3范围内） |
| 404 | 地区不存在（如：查询的ID不存在） |
| 500 | 服务器内部错误 |

**错误响应示例**：
```json
{
  "code": 404,
  "message": "地区不存在"
}
```

---

## 8. 注意事项

1. **ID使用国标代码**：地区ID直接使用国家标准行政区划代码，保证数据权威性和稳定性

2. **缓存建议**：
   - 前端：建议使用 localStorage 缓存地区数据，有效期可设置为7天或更长
   - 后端：建议使用 Redis 缓存地区查询结果，提升接口性能

3. **性能优化**：
   - 地区数据量适中（全国约3200个区县），单次查询返回数据量不大
   - 省级列表约34条数据，市级列表最多300+条，区县列表最多100+条
   - 无需分页，可一次性返回

4. **状态字段**：
   - `status=1`：正常启用，前端正常显示
   - `status=0`：已禁用（如行政区划调整），前端应过滤或特殊标记

5. **历史数据兼容性**：
   - 使用国标区划代码作为ID，保证历史数据的一致性
   - 即使未来行政区划调整，历史订单中的地区ID仍然有效
   - 如有地区合并或撤销，可通过 `status=0` 标记，但ID保留

6. **数据完整性**：
   - 所有用户和订单必须关联有效的地区ID
   - 建议在数据库层面设置外键约束（可选）
   - 前端提交前验证地区ID是否存在且启用

7. **显示优化**：
   - 建议后端返回数据时，通过 JOIN 查询同时返回地区名称
   - 减少前端多次查询，提升用户体验

8. **数据导入**：
   - 项目初始化时需导入地区数据
   - 参考 `scripts/import-regions.js` 或 `scripts/import-regions-local.js`
   - 详见 `database/README_REGIONS.md`

---

## 9. 相关文档

- [数据库表结构设计 - regions表](../database/README.md)
- [地区数据导入指南](../database/README_REGIONS.md)
- [用户管理接口](./接口设计-用户端.md)
- [动物订购接口](./接口设计-管理端-动物订购.md)
- [试剂耗材接口](./接口设计-管理端-试剂耗材.md)
